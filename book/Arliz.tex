\documentclass[12pt, oneside, openany]{book}

%----------------------------------------------
% Encoding and Typography Enhancements
%----------------------------------------------
\usepackage[T1]{fontenc}            % Enhanced font encoding
\usepackage[utf8]{inputenc}         % Direct Unicode input
\usepackage{microtype}              % Fine-tune character spacing for better typography

%----------------------------------------------
% Primary and Mathematical Fonts
%----------------------------------------------
\usepackage{charter}                % Charter: legible serif for body text
\usepackage{mathpazo}               % Palatino-like math fonts
\usepackage{bm}                     % Bold math symbols

%----------------------------------------------
% Monospaced Font for Code Listings
%----------------------------------------------
\usepackage[scaled=.95]{inconsolata} % Inconsolata for code

%----------------------------------------------
% Page Layout and Spacing
%----------------------------------------------
\usepackage[a4paper, margin=1in]{geometry} % 1" margins on A4
\usepackage{setspace}              % Line-spacing control
\setstretch{1.3}                   % 1.3× line spacing

%----------------------------------------------
% Headers and Footers
%----------------------------------------------
\usepackage{fancyhdr}              % Fancy header/footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\nouppercase{\leftmark}} % Chapter title on left
\fancyhead[R]{\thepage}               % Page number on right
\fancypagestyle{plain}{               % Plain pages (e.g., chapter starts)
	\fancyhf{}
	\fancyfoot[C]{\thepage}
}

%----------------------------------------------
% Hyperlinks and PDF Metadata
%----------------------------------------------
\usepackage{hyperref}
\hypersetup{
	colorlinks    = true,
	linkcolor     = black,    % Internal links in black (print-friendly)
	citecolor     = blue,     % Citation links in blue
	urlcolor      = cyan,     % URLs in cyan
	pdfauthor     = {Mahdi},
	pdftitle      = {Arliz},
	pdfsubject    = {Programming, Arrays, and Data Structures},
	pdfkeywords   = {Arrays, Data Structures, Programming, History of Computing}
}

%----------------------------------------------
% Graphics and Diagrams
%----------------------------------------------
\usepackage{graphicx}             % Include images
\usepackage{caption}              % Customize captions
\usepackage{subcaption}           % Sub-figures support
\usepackage{xcolor}               % Color definitions
\usepackage{tikz}                 % Vector graphics & diagrams
\usetikzlibrary{positioning, shapes.geometric, arrows, calc}

%----------------------------------------------
% Tables and Arrays
%----------------------------------------------
\usepackage{array}                % Extended tabular features

%----------------------------------------------
% Section and Title Formatting
%----------------------------------------------
\usepackage{titlesec}             % Control title styles
\titleformat{\chapter}[display]
{\normalfont\huge\bfseries}{\chaptername\ \thechapter}{20pt}{\Huge}
\titleformat{\section}
{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
{\large\bfseries}{\thesubsection}{1em}{}

%----------------------------------------------
% Code Listings and Pseudocode
%----------------------------------------------
\usepackage{listings}             % Source code highlighting
\lstset{
	basicstyle      = \ttfamily\small,
	frame           = single,
	breaklines      = true,
	numbers         = left,
	numberstyle     = \tiny\color{gray},
	keywordstyle    = \color{myblue}\bfseries,
	commentstyle    = \color{olive},
	stringstyle     = \color{orange},
	backgroundcolor = \color{lightgray!20},
	captionpos      = b,
	escapeinside    = {(*@}{@*)},
	morekeywords    = {array, structure, algorithm, complexity}
}

\usepackage{algorithm}             % Algorithm floats
\usepackage{algpseudocode}         % Pseudocode environment

%----------------------------------------------
% Color Definitions
%----------------------------------------------
\definecolor{myblue}{RGB}{0, 102, 204}     % Custom blue for code
\definecolor{lightgray}{RGB}{240, 240, 240} % Light gray background

%----------------------------------------------
% Special Boxes and Environments
%----------------------------------------------
\usepackage{tcolorbox}
\tcbuselibrary{most}

\newtcolorbox{notebox}[1][]{
	colback   = blue!5!white,
	colframe  = blue!75!black,
	title     = Note,
	#1
}
\newtcolorbox{tipbox}[1][]{
	colback   = green!5!white,
	colframe  = green!75!black,
	title     = Tip,
	#1
}
\newtcolorbox{warningbox}[1][]{
	colback   = red!5!white,
	colframe  = red!75!black,
	title     = Important,
	#1
}

%----------------------------------------------
% Bibliography and Citations
%----------------------------------------------
\usepackage[backend=biber,style=apa]{biblatex}
\addbibresource{references.bib}

%----------------------------------------------
% Table of Contents, Bibliography, Index
%----------------------------------------------
\usepackage{tocbibind}            % Include TOC adds
\usepackage{imakeidx}             % Index creation
\makeindex

%----------------------------------------------
% Multiple Columns (e.g., Glossary)
%----------------------------------------------
\usepackage{multicol}

%----------------------------------------------
% PDF Inclusion (e.g., for front matter pages)
%----------------------------------------------
\usepackage{pdfpages}
\begin{document}
	\includepdf[pages=-, pagecommand={\thispagestyle{empty}}, width=\paperwidth, height=\paperheight]{logo.pdf}
	
	\frontmatter
	% Title Page (Front Matter)

\begin{titlepage}
	\begin{center}
		\vspace*{2cm}

		{\Huge\bfseries In Praise of Arliz}\\[2em]
		
		{\Large\scshape Mahdi}\\[0.5em]
		
		\begin{minipage}{1\textwidth}
			\centering
			This book evolves. Every insight gained—whether a circuit, a structure,\\
				or a simple idea—is absorbed and integrated. 
		\end{minipage}
		
		\vfill
		
	{\large \textsc{First Edition}}\\[0.5em]
	{\large \today}
	
	\vspace*{1cm}
	{\small
		\textcopyright\ 2025 Mahdi “Genix”  
		\par
		Released under the MIT License  
	}
	\end{center}
\end{titlepage}

%----------------------------------------------
% Dedication
%----------------------------------------------
\thispagestyle{empty}
\vspace*{6cm}
\begin{center}
	\emph{
		To those who build from first principles.\\
		To the silent thinkers who design before they speak.\\
		To the ones who see in systems—\\
		not just machines, but metaphors.\\
		This is for you.}
\end{center}

\pagestyle{empty}
	\chapter*{Preface}
	\thispagestyle{empty}

	%\maketitle
	Every book has its own story, and this book is no exception. If I were to summarize the process of creating this book in one word, that word would be “improvised.” Yet the truth is that Arliz is the result of pure, persistent curiosity that has grown in my mind for years. What you are reading now could be called a technical book, a collection of personal notes, or even a journal of unanswered questions and curiosities. But I—officially—call it a \emph{book}, because it is written not only for others but for myself, as a record of my learning journey and an effort to understand more precisely the concepts that once seemed obscure and, at times, frustrating.\\
	The story of Arliz began with a simple feeling: \textbf{curiosity}.  
	Curiosity about what an array truly is. Perhaps for many this question seems trivial, but for me this word—encountered again and again in algorithm and data structure discussions—always raised a persistent question.\\
	Every time I saw terms like \texttt{array}, \texttt{stack}, \texttt{queue}, \texttt{linked list}, \texttt{hash table}, or \texttt{heap}, I not only felt confused but sensed that something fundamental was missing. It was as if a key piece of the puzzle had been left out. The first brief, straightforward explanations I found in various sources never sufficed; they assumed you already knew exactly what an array is and why you should use it. But I was looking for the \emph{roots}. I wanted to understand from zero what an array means, how it was born, and what hidden capacities it holds.\\
	That realization led me to decide:  
	\emph{If I truly want to understand, I must start from zero.}\\	
	There is no deeper story behind the name “Arliz.” There is no hidden philosophy or special inspiration—just a random choice. I simply declared:  
	\emph{This book is called Arliz.}  
	You may pronounce it "Ar-liz," "Array-Liz," or any way you like. I personally say "ar-liz." That is all—simple and arbitrary.\\	
	But Arliz is not merely a technical book on data structures. In fact, \textbf{Arliz grows alongside me}. \\
	Whenever I learn something I deem worth writing, I add it to this book. Whenever I feel a section could be explained better or more precisely, I revise it. Whenever a new idea strikes me—an algorithm, an exercise, or even a simple diagram to clarify a structure—I incorporate it into Arliz.\\
	This means Arliz is a living project. As long as I keep learning, Arliz will remain alive.\\	
	The structure of this book has evolved around a simple belief: true understanding begins with context. That’s why Arliz doesn’t start with code or syntax, but with the origins of computation itself. We begin with the earliest tools and ideas—counting stones, the abacus, mechanical gears, and early notions of logic—long before transistors or binary digits came into play. From there, we follow the evolution of computing: from ancient methods of calculation to vacuum tubes and silicon chips, from Babbage’s Analytical Engine to the modern microprocessor. Along this journey, we discover that concepts like arrays aren’t recent inventions—they are the culmination of centuries of thought about how to structure, store, and process information.\\
	In writing this book, I have always tried to follow three principles:
	
	\begin{itemize}
		\item \textbf{Simplicity of Expression:} I strive to present concepts in the simplest form possible, so they are accessible to beginners and not superficial or tedious for experienced readers.
		\item \textbf{Concept Visualization:} I use diagrams, figures, and visual examples to explain ideas that are hard to imagine, because I believe visual understanding has great staying power.
		\item \textbf{Clear Code and Pseudocode:} Nearly every topic is accompanied by code that can be easily translated into major languages like C\texttt{++}, Java, or C\#, aiming for both clarity and practicality.
	\end{itemize}
	
	An important note: many of the algorithms in Arliz are implemented by myself. I did not copy them from elsewhere, nor are they necessarily the most optimized versions. My goal has been to understand and build them from scratch rather than memorize ready-made solutions. Therefore, some may run slower than standard implementations—or sometimes even faster. For me, the process of understanding and constructing has been more important than simply reaching the fastest result.\\	
	Finally, let me tell you a bit about myself:  
	I am \textbf{Mehdi}. If you prefer, you can call me by my alias: \emph{Genix}. I am a student of Computer Engineering (at least at the time of writing this). I grew up with computers—from simple games to typing commands in the terminal—and I have always wondered what lies behind this screen of black and green text. There is not much you need to know about me, just that I am someone who works with computers, sometimes gives them commands, and sometimes learns from them.\\	
	I hope this book will be useful for understanding concepts, beginning your learning journey, or diving deeper into data structures. \\	
	Arliz is freely available. You can access the PDF, LaTeX source, and related code at:  
	\begin{center}
		\url{https://github.com/m-mdy-m/Arliz}
	\end{center}
	In each chapter, I have included exercises and projects to aid your understanding. Please do not move on until you have completed these exercises, because true learning happens only by solving problems.\\	
	I hope this book serves you well—whether for starting out, reviewing, or simply satisfying your curiosity. And if you learn something, find an error, or have a suggestion, please let me know. As I said:
	\emph{This book grows with me.}
	
	% Acknowledgments
	\pagestyle{empty}
	\chapter*{Acknowledgments}
		\thispagestyle{empty}
		I would like to express my gratitude to everyone who supported me during the creation of this book. Special thanks to the open-source community for their invaluable resources and to all those who reviewed early drafts and provided feedback.
		
		%\maketitle

	\tableofcontents
	\renewcommand{\arraystretch}{1.5} % Adjust row height for better readability
% Main Content
\mainmatter

\part{The Birth of Computing: From Mechanical to Electronic}

\section*{Introduction}

Long before a single line of code was ever written—long before electricity, transistors, or even the concept of modern logic circuits—humans felt an innate drive to calculate, record, and model the world around them. Computing is not a recent invention. It is one of humanity’s oldest intellectual pursuits, rooted in necessity and evolved through creativity. Before we dive into complex abstractions like arrays or data structures, we must ask a deeper, almost philosophical question: \textbf{What does it mean to compute?}\\
This part of the book invites you on a journey—not just through the machinery and breakthroughs that brought us the modern computer, but through the evolution of human thought about numbers, representation, and control. Arrays, as we will later explore in depth, are not merely structures to store data. They are reflections of how we’ve ordered information for thousands of years. Their logic is built upon ancient insights—on sets, sequences, and patterns—and they embody the fundamental human need to represent, repeat, and manipulate structured information.\\
Our journey begins in ancient times, long before Christ, with devices like the abacus, first appearing over 2,500 years ago in Mesopotamia and later refined by Chinese, Roman, and Japanese cultures. The abacus was not just a calculator—it was an embodiment of the concepts of \textbf{state}, \textbf{position}, and \textbf{transformation}, principles that continue to underpin all modern computation. It allowed people to model quantities, track multiple values in parallel (an early echo of array indexing), and perform operations based on positional representation.\\
From these early tools, we progress into the classical mathematical age, where the Greeks formalized logic, and concepts like \textbf{sets} and \textbf{ordered lists} began to take philosophical shape. While not arrays in the modern sense, these ideas laid the intellectual groundwork for thinking about groups of data—grouped, related, or sequential—that could be acted upon as a whole. The set, in particular, became a foundational concept in mathematics and later in programming: an abstract container for elements that obey rules and enable operations. The leap from abstract sets to concrete arrays reflects one of the key transitions in computational history—from idea to implementation.\\
In the 17th century, visionaries like Blaise Pascal and Gottfried Wilhelm Leibniz attempted to automate arithmetic with mechanical devices. These weren’t just clever tools—they were the first signs of a dream to make thinking itself mechanical. Charles Babbage expanded this dream with his Analytical Engine in the 19th century, envisioning a machine that could be programmed and reprogrammed—a concept that wouldn’t become reality until a century later. Ada Lovelace, who worked with Babbage, went even further. She grasped that machines could go beyond numbers: they could process symbolic logic, follow instructions, and even imitate aspects of reasoning. She anticipated the algorithm as a mental construct, not just a set of steps.\\
As we move forward into the 20th century, the invention of electromechanical and electronic machines—using relays, vacuum tubes, and later transistors—marked a revolution. No longer limited by gears and levers, computers became faster, more reliable, and more abstract. The idea of a \textbf{stored program} emerged, allowing machines to modify their behavior dynamically. This wasn’t just a technical innovation—it was a conceptual transformation. Programs became data, and data became active. Arrays, now implemented in memory, could be changed, traversed, and manipulated at runtime—opening the door to software as we know it today.\\
Eventually, we arrive at logic gates, boolean algebra, and the transistor—the atomic units of modern computation. These are more than circuits; they are the physical embodiment of logical thought: conditions, branching, repetition. From gates we build circuits, from circuits microprocessors, and from those, machines that can simulate anything we can formalize.\\
Before concluding this part, we will look closely at how data is represented: binary numbers, encoding schemes, floating-point formats, and character representations. These are not just technical tools; they are perspectives. They define the limits of what a machine can know, express, and manipulate. And finally, we arrive at memory—where arrays live, grow, and function. Memory is not just storage; it is the canvas of computation. It is where change happens and where order emerges.\\
If you are excited to write code, build systems, and jump into implementation, you are free to skip ahead. But if you stay with us for this brief but essential historical and conceptual journey, you will see programming not just as control over a machine, but as part of a much older story: the story of how humans learned to structure thought, encode logic, and make abstract ideas come alive.\\
Let us begin—at the beginning. With sand, stone, wood, and brass. And with minds bold enough to imagine machines that think.

% ==========================================
% CHAPTER 1: PHILOSOPHICAL FOUNDATIONS
% ==========================================

\chapter{What Does It Mean to Compute?}

\section{The Human Urge to Measure and Represent}

\section{From Counting Stones to Conceptual Models}

\section{Mathematical Roots of Arrays}

% ==========================================
% CHAPTER 2: ANCIENT COMPUTING TOOLS
% ==========================================

\chapter{Ancient Tools of Structured Computation}

\section{The Abacus: Humanity's First Array-Like Structure}

\section{Ancient Number Tables: Proto-Arrays in Practice}

\section{Chinese Rod Numerals and Matrix Operations}

% ==========================================
% CHAPTER 3: MEDIEVAL AND RENAISSANCE
% ==========================================

\chapter{Medieval and Renaissance: Systematization of Knowledge}

\section{Islamic Golden Age Contributions}

\section{Renaissance Calculating Tools}

\section{The Emergence of Systematic Notation}

% ==========================================
% CHAPTER 4: MECHANICAL COMPUTATION
% ==========================================

\chapter{Mechanical Computation: The Dream of Automated Thinking}

\section{Early Mechanical Calculators}

\section{Charles Babbage's Visionary Machines}

\section{Ada Lovelace: The First Programmer}

% ==========================================
% CHAPTER 5: ELECTROMECHANICAL ERA
% ==========================================

\chapter{The Electromechanical Revolution}

\section{From Mechanical to Electrical}

\section{Early 20th Century Computing Machines}


% ==========================================
% CHAPTER 6: ELECTRONIC COMPUTING BIRTH
% ==========================================

\chapter{The Birth of Electronic Computing}

\section{The Vacuum Tube Revolution}
\section{The Stored Program Concept}

% ==========================================
% CHAPTER 7: DIGITAL LOGIC FOUNDATIONS
% ==========================================

\chapter{Digital Logic: The Foundation of Modern Arrays}

\section{Boolean Algebra and Logical Operations}

\section{Transistors: The Atomic Units of Computation}

\section{Building Complex Circuits}


% ==========================================
% CHAPTER 8: NUMBER SYSTEMS AND REPRESENTATION
% ==========================================

\chapter{Number Systems and Data Representation}
\section{Historical Counting Systems}
\section{Binary: The Language of Digital Machines}
\section{Floating-Point: Representing the Continuous}
\section{Character Encoding Evolution}

% ==========================================
% CHAPTER 9: MEMORY ARCHITECTURE
% ==========================================

\chapter{Memory: The Canvas Where Arrays Live}

\section{Historical Storage Evolution}
\section{Modern Memory Architecture}
\section{Address Space and Virtual Memory}
\section{Memory Layout in Program Execution}
\section{Array Storage and Memory Layout}
	

\end{document}