%==============================================
% PART 2: COMPUTER ARCHITECTURE & LOGIC
%==============================================
\part{Computer Architecture \& Logic}
\label{part:architecture-logic}

\begin{partintro}
\lettrine[lines=3]{A}{rrays exist} in physical hardware. To understand array performance, we must understand the machines that execute our codeâ€”from transistors to complete systems. This part builds a complete picture of computational machinery.

\vspace{1em}
\textbf{What Makes This Different:}
\begin{itemize}[noitemsep]
    \item \textbf{Silicon to Software:} Complete vertical integration
    \item \textbf{Modern Architecture:} Multi-core, SIMD, heterogeneous systems
    \item \textbf{Performance Foundations:} Why code runs fast or slow
    \item \textbf{Hardware-Software Contract:} What each layer assumes
\end{itemize}

\begin{quote}
\textit{``The purpose of computing is insight, not numbers.''}

\hfill--- \textsc{Richard Hamming}
\end{quote}
\end{partintro}

\chapter{Semiconductor Physics Foundations}
Silicon properties, doping (n-type, p-type), P-N junctions, depletion regions, how semiconductors enable switching.

\chapter{MOSFET Transistors}
Gate, source, drain, channel, threshold voltage, NMOS and PMOS, how transistors act as switches.

\chapter{CMOS Logic Fundamentals}
Complementary MOS, pull-up and pull-down networks, static power vs. dynamic power, why CMOS won.

\chapter{Logic Gate Implementation}
CMOS implementation of NOT, NAND, NOR gates, gate delay, rise/fall time, fan-out limitations.

\chapter{Logic Gate Families}
AND, OR, XOR, XNOR from NAND/NOR, transmission gates, tri-state buffers.

\chapter{Combinational Circuit Design}
Truth tables to logic expressions, Karnaugh maps, minimization, multi-level logic.

\chapter{Arithmetic Circuits: Adders}
Half adder, full adder, ripple-carry adder, carry-lookahead adder, carry-select adder.

\chapter{Arithmetic Circuits: Multipliers and Dividers}
Array multiplier, Booth multiplier, Wallace tree, division algorithms, restoring vs. non-restoring.

\chapter{Multiplexers and Demultiplexers}
2:1 mux, 4:1 mux, tree structures, using muxes for logic implementation.

\chapter{Encoders and Decoders}
Binary encoding, priority encoding, 7-segment decoder, address decoding.

\chapter{Arithmetic Logic Circuits}
Half adder, full adder, ripple-carry adder, carry-lookahead adder, carry-save adder, subtraction using two's complement, magnitude comparators.

\chapter{Advanced Arithmetic Units}
Multipliers (array multiplier, Booth's algorithm, Wallace tree), dividers, floating-point units (FPUs), fused multiply-add (FMA).

\chapter{Sequential Logic Fundamentals}
Difference between combinational and sequential logic, feedback, state, clock signals, synchronous versus asynchronous design.

\chapter{Comparators and Magnitude Detection}
Equality comparator, magnitude comparator, signed vs. unsigned comparison.

\chapter{Sequential Logic Fundamentals}
Need for memory elements, clock signals, synchronous vs. asynchronous design.

\chapter{Latches: SR, D Latches}
Set-reset latch, gated D latch, transparent latch, latch vs. flip-flop distinction.

\chapter{Flip-Flops: D, JK, T Flip-Flops}
Edge-triggered flip-flops, master-slave configuration, setup and hold time, clock-to-Q delay.

\chapter{Registers and Register Files}
Parallel-load register, shift registers (SISO, SIPO, PISO, PIPO), register banks for CPU.

\chapter{Counters and Timers}
Ripple counter, synchronous counter, up/down counter, modulo-N counter, timer circuits.

\chapter{Finite State Machines}
Moore vs. Mealy machines, state diagrams, state table, state minimization, FSM implementation.

\chapter{Memory Cell Design: SRAM}
6-transistor SRAM cell, read and write operations, stability analysis, SRAM array organization.

\chapter{Memory Cell Design: DRAM}
1-transistor 1-capacitor cell, charge storage, sense amplifiers, refresh requirement.

\chapter{Memory Array Organization}
Row and column decoding, wordline and bitline, memory cell array structure, address multiplexing.

\chapter{DRAM Operation and Timing}
Row activation, column access, precharge, timing parameters (tRCD, tRP, tRAS, CAS latency).

\chapter{DRAM Generations}
SDR SDRAM, DDR, DDR2, DDR3, DDR4, DDR5, bandwidth evolution, power efficiency.

\chapter{Advanced DRAM Features}
Burst mode, bank interleaving, dual-channel, command queuing, on-die termination.

\chapter{Non-Volatile Memory Technologies}
Flash memory (NAND, NOR), program/erase cycles, wear leveling, EEPROM, ROM variants.

\chapter{Flash Memory Operations}
Programming (writing), erasing, read operations, wear leveling, write amplification, garbage collection, over-provisioning.

\chapter{Emerging Memory Technologies}
Phase-change memory (PCM), resistive RAM (ReRAM), magnetoresistive RAM (MRAM), 3D XPoint.

\chapter{Memory Hierarchy Fundamentals}
Pyramid structure, latency-capacity tradeoffs, why hierarchies exist, locality principles.

\chapter{Cache Memory Fundamentals}
Temporal locality, spatial locality, cache line (block), tag-data organization.

\chapter{Cache Mapping Strategies}
Direct-mapped cache, fully-associative cache, set-associative cache (2-way, 4-way, 8-way, N-way).

\chapter{Cache Replacement Policies}
LRU (least recently used), LFU, FIFO, random, pseudo-LRU, practical implementations.

\chapter{Cache Write Policies}
Write-through, write-back, write-allocate, no-write-allocate, dirty bits.

\chapter{Multi-Level Cache Hierarchies}
L1 instruction and data caches, unified L2 cache, L3 shared cache, inclusive vs. exclusive caches.

\chapter{Victim Caches and Advanced Structures}
Victim cache for conflict misses, stream buffers for prefetching, trace caches.

\chapter{Cache Coherence Problem}
Shared memory multiprocessors, cache inconsistency, coherence vs. consistency.

\chapter{Cache Coherence Protocols: MESI}
Modified, Exclusive, Shared, Invalid states, state transitions, bus snooping.

\chapter{Cache Coherence Protocols: MOESI and Beyond}
Owned state, directory-based coherence, scalability issues.

\chapter{Cache Performance Analysis}
Hit rate, miss rate, average memory access time (AMAT), miss penalty, classifying misses (compulsory, capacity, conflict).

\chapter{Cache Optimization Techniques}
Blocking/tiling, array padding, loop interchange, prefetching, cache-aware algorithms.

\chapter{Instruction Set Architecture (ISA)}
RISC versus CISC philosophy, instruction encoding and formats, addressing modes, register architecture, condition codes.

\chapter{x86 Architecture}
x86 instruction encoding, variable-length instructions, complex addressing modes, backward compatibility, x86-64 extensions.

\chapter{ARM Architecture}
Load-store architecture, fixed-length instructions (ARM mode), Thumb instruction set, NEON SIMD, ARM versus x86 comparison.

\chapter{RISC-V Architecture}
Open ISA, modular extensions, base integer instruction set, standard extensions (M, A, F, D, C), design philosophy.

\chapter{Pipelining Fundamentals}
Instruction pipeline stages (IF, ID, EX, MEM, WB), throughput improvement, latency, ideal CPI, pipeline diagrams.

\chapter{Pipeline Hazards}
Structural hazards, data hazards (RAW, WAR, WAW), control hazards, stalls and bubbles, hazard detection and resolution.

\chapter{Data Forwarding and Bypassing}
Forwarding paths, bypassing results from later stages, forwarding logic, load-use hazard, limitations of forwarding.

\chapter{Branch Handling in Pipelines}
Branch penalty, delayed branches, branch prediction necessity, flushing pipeline on misprediction, branch delay slots.

\chapter{Branch Prediction Techniques}
Static prediction (always taken, always not-taken, backward taken forward not-taken), dynamic prediction, branch history.

\chapter{Advanced Branch Prediction}
Two-bit saturating counters, branch history table (BHT), branch target buffer (BTB), two-level adaptive predictors, tournament predictors.

\chapter{Return Address Stack}
Function call prediction, hardware return address stack, depth and accuracy, correlation with call-return patterns.

\chapter{Superscalar Architecture}
Multiple issue, instruction-level parallelism (ILP), dispatch width, execution units, dependency checking, instruction window.

\chapter{Out-of-Order Execution}
Tomasulo's algorithm, reservation stations, register renaming, reorder buffer (ROB), commit stage, speculative execution.

\chapter{Register Renaming}
Eliminating false dependencies (WAR, WAW), physical versus architectural registers, register alias table (RAT), freelist management.

\chapter{Speculative Execution}
Branch speculation, memory speculation, exceptions in speculative execution, precise interrupts, ROB and commit.

\chapter{Speculative Execution Vulnerabilities}
Spectre attacks (branch target injection, bounds check bypass), Meltdown (rogue data cache load), side-channel exploitation, mitigations.

\chapter{Memory Hierarchy Principles}
Principle of locality (temporal and spatial), access time gaps, capacity and cost tradeoffs, memory wall problem.

\chapter{Virtual Memory Fundamentals}
Virtual address space, physical address space, address translation, memory protection.

\chapter{Page Tables and Address Translation}
Page table entry structure, multi-level page tables, page table walk.

\chapter{Translation Lookahead Buffer (TLB)}
TLB structure, TLB hit/miss, TLB reach, large pages (huge pages, superpages).

\chapter{Page Replacement Algorithms}
Optimal (Belady), FIFO, LRU, clock (second chance), working set model.

\chapter{Demand Paging and Page Faults}
Page fault handling, major vs. minor faults, swap space, thrashing.

\chapter{Memory Management Unit (MMU)}
Hardware implementation, page table base register, protection bits, privilege levels.

\chapter{Memory Protection and Isolation}
Process isolation, kernel vs. user space, protection rings, segmentation.

\chapter{CPU Microarchitecture Overview}
Instruction fetch, decode, execute, memory, writeback, datapath and control path.

\chapter{Instruction Set Architecture Principles}
Instruction formats, operand addressing, register vs. memory operands, RISC philosophy.

\chapter{CISC vs. RISC}
Complex instruction set (x86), reduced instruction set (ARM, RISC-V), microcode, instruction encoding density.

\chapter{Register Architecture}
General-purpose registers, special-purpose registers (PC, SP, flags), register windows, register renaming.

\chapter{Addressing Modes}
Immediate, register direct, memory direct, register indirect, indexed, PC-relative, stack addressing.

\chapter{Instruction Encoding}
Fixed-length vs. variable-length, opcode, operands, prefix bytes (x86), instruction alignment.

\chapter{Pipelining Fundamentals}
Instruction pipeline stages, throughput vs. latency, ideal speedup, pipeline registers.

\chapter{Pipeline Hazards}
Structural hazards, data hazards (RAW, WAR, WAW), control hazards (branches).

\chapter{Data Forwarding and Bypassing}
Forwarding paths, resolving data hazards, bypass network.

\chapter{Pipeline Stalls and Bubbles}
When forwarding isn't enough, NOP insertion, performance impact.

\chapter{Branch Prediction Fundamentals}
Static prediction, dynamic prediction, branch history, importance for performance.

\chapter{Branch Prediction: Simple Schemes}
1-bit predictor, 2-bit saturating counter, bimodal predictor.

\chapter{Branch Prediction: Advanced Schemes}
Two-level adaptive predictors, local vs. global history, correlating predictors.

\chapter{Branch Target Buffer and Return Stack}
BTB for target prediction, return address stack (RAS) for function returns, indirect branch prediction.

\chapter{Speculative Execution}
Executing before knowing if needed, branch prediction enabling speculation, squashing mispredicted paths.

\chapter{Out-of-Order Execution}
Instruction reordering, Tomasulo's algorithm, reservation stations, reorder buffer.

\chapter{Register Renaming}
Eliminating false dependencies (WAR, WAW), physical vs. architectural registers, register allocation table.

\chapter{Instruction Scheduling}
Issue width, instruction window, dependency checking, wake-up and select logic.

\chapter{Superscalar Execution}
Multiple issue, dispatch width, execution units, commit width, IPC (instructions per cycle).

\chapter{Very Long Instruction Word (VLIW)}
Static scheduling by compiler, explicit parallelism, no dependency checking hardware, Itanium example.

\chapter{Simultaneous Multithreading (SMT)}
Hyper-threading, thread-level parallelism, sharing execution resources, Intel and AMD implementations.

\chapter{Memory Ordering and Consistency}
Load/store reordering, memory fences, barriers, acquire-release semantics.

\chapter{Consistency Models}
Sequential consistency, total store order (TSO), weak ordering, relaxed models.


\chapter{Input/Output Systems}
I/O devices and controllers, I/O address space (port-mapped versus memory-mapped I/O), programmed I/O, interrupt-driven I/O.

\chapter{Interrupt Handling}
Interrupt request (IRQ), interrupt vector table, interrupt service routine (ISR), interrupt priority, nested interrupts, interrupt latency.

\chapter{Direct Memory Access (DMA)}
DMA controller, bus mastering, DMA transfer modes (burst, cycle stealing), scatter-gather DMA, reducing CPU overhead.

\chapter{I/O Buses and Interconnects}
System bus, front-side bus, peripheral buses, PCIe (lanes, endpoints, root complex), bus arbitration, bandwidth and latency.

\chapter{Storage Controllers and Interfaces}
SATA, SAS, NVMe, NVMe over Fabrics, command queuing, storage protocol stack, queue depth and parallelism.

\chapter{Multi-Core Processors}
Chip multiprocessors (CMP), symmetric multiprocessing (SMP), shared L2/L3 caches, on-chip interconnect (ring, mesh, crossbar).

\chapter{NUMA Architecture}
Non-uniform memory access, memory affinity, local versus remote memory, NUMA domains, NUMA-aware programming.

\chapter{SIMD and Vector Processing}
Single instruction multiple data, vector registers, lane-based execution, packed operations.

\chapter{x86 SIMD Extensions}
MMX, SSE, SSE2-SSE4, AVX, AVX2, AVX-512, register width evolution.

\chapter{ARM NEON and SVE}
NEON instruction set, Scalable Vector Extension, predication, variable vector length.

\chapter{GPU Architecture Overview}
Massively parallel architecture, streaming multiprocessors, SIMT execution model.

\chapter{GPU Execution Model}
Threads, warps/wavefronts, thread blocks, grid, kernel launch, occupancy.

\chapter{GPU Memory Hierarchy}
Global memory, shared memory, registers, constant memory, texture memory, L1/L2 caches.

\chapter{GPU Programming Models}
CUDA, OpenCL, compute shaders, host-device interaction, kernel code.

\chapter{Input/Output Architecture}
I/O devices, device controllers, I/O buses, programmed I/O vs. interrupt-driven I/O.

\chapter{Interrupt Mechanism}
Interrupt vector table, interrupt service routines, interrupt priority, nested interrupts.

\chapter{Interrupt Handling Details}
Context saving/restoration, interrupt latency, interrupt masking, edge vs. level triggered.

\chapter{Exception Handling}
Faults, traps, aborts, exception vectors, privilege level transitions.

\chapter{Direct Memory Access (DMA)}
DMA controllers, bus mastering, scatter-gather DMA, DMA descriptors, reducing CPU overhead.

\chapter{I/O Memory Management Unit (IOMMU)}
Device address translation, DMA protection, virtualization support, IOMMU page tables.

\chapter{Bus Architecture and Protocols}
System bus, memory bus, I/O bus, bus arbitration, split transactions.

\chapter{Interconnect Fabrics}
Point-to-point links, crossbar switches, mesh networks, ring interconnects.

\chapter{PCIe Architecture}
Lanes, link width, generations (1.0-6.0), packets and transactions, TLP/DLLP/Physical layers.

\chapter{Cache-Coherent Interconnects}
Intel QPI/UPI, AMD Infinity Fabric, coherence traffic, non-uniform cache access (NUCA).

\chapter{Network-on-Chip (NoC)}
On-chip routing, wormhole routing, virtual channels, deadlock avoidance.

\chapter{Power Management Mechanisms}
Dynamic voltage and frequency scaling (DVFS), clock gating, power gating, C-states, P-states.

\chapter{Thermal Design and Throttling}
Thermal design power (TDP), temperature monitoring, thermal throttling, cooling solutions.

\chapter{Hardware Performance Counters}
Performance monitoring units (PMU), counting events (cycles, instructions, cache misses, branch mispredictions).

\chapter{Profiling with Hardware Counters}
Perf tools, VTune, hardware event sampling, attributing performance to code.

\chapter{Hardware Security Features}
Secure boot, trusted execution environments (SGX, TrustZone), memory encryption (SEV, TME).

\chapter{Spectre and Meltdown}
Speculative execution vulnerabilities, side-channel attacks, mitigations (KPTI, retpoline, microcode updates).

\chapter{Memory Safety Mechanisms}
Bounds checking (Intel MPX), pointer authentication (ARM PAC), tagged memory, stack canaries.

\chapter{Hardware Debugging Infrastructure}
JTAG, boundary scan, trace debugging, watchpoints, breakpoints.

%----------------------------------------------
% MOBILE DEVICE HARDWARE SECTION
%----------------------------------------------

\chapter{Mobile Device System-on-Chip (SoC) Architecture}
Integrated CPU, GPU, modem, ISP on single die, ARM Cortex cores, heterogeneous computing, power islands, mobile SoC vendors (Qualcomm, Apple, MediaTek).

\chapter{Mobile Power Management IC (PMIC)}
Voltage regulation, power sequencing, buck converters, LDO regulators, battery charging control, thermal management, power state transitions.

\chapter{Mobile Display Technology and Controllers}
LCD vs OLED, display driver IC, timing controller (TCON), MIPI DSI interface, backlight control, touch controller integration, digitizer architecture.

\chapter{Mobile Battery Management Systems}
Lithium-ion chemistry, charge cycles, protection circuits, fuel gauge IC, State of Charge (SoC) estimation, State of Health (SoH), battery authentication.

\chapter{Mobile Charging Circuit Architecture}
USB Power Delivery, Quick Charge, voltage/current regulation, thermal throttling, charge pump topology, wireless charging (Qi standard), reverse charging.

\chapter{Mobile Baseband and RF Subsystems}
Modem architecture, RF transceiver, power amplifier, antenna tuning, MIMO configuration, cellular bands, signal integrity, EMI considerations.

\chapter{Mobile Audio Codec and Amplifier}
Digital-to-analog conversion, headphone amplifier, speaker amplifier, noise cancellation, audio routing, microphone bias, impedance matching.

\chapter{Mobile Camera ISP and Sensor Interface}
Image signal processor, MIPI CSI, sensor array, autofocus driver, optical image stabilization (OIS), electronic image stabilization (EIS).

%----------------------------------------------
% COMPUTER HARDWARE REPAIR SECTION
%----------------------------------------------

\chapter{Motherboard Component Identification}
Visual inspection techniques, component labeling conventions, voltage regulator modules (VRM), chipset identification, power delivery phases, capacitor types (electrolytic, ceramic, tantalum).

\chapter{Desktop Power Supply Unit Architecture}
ATX standard, 12V rails, 5V standby, power good signal, overcurrent protection, ripple suppression, efficiency ratings (80 Plus), modular vs non-modular.

\chapter{Power Supply Diagnostic Techniques}
Paperclip test, multimeter voltage verification, load testing, ripple measurement, fan operation check, capacitor bulging inspection, burning smell identification.

\chapter{RAM Architecture and Organization}
DIMM vs SO-DIMM, DDR generations, module organization (single-rank, dual-rank), SPD (Serial Presence Detect), XMP profiles, memory timings (CL, tRCD, tRP, tRAS).

\chapter{RAM Testing Methodologies}
MemTest86, Windows Memory Diagnostic, POST beep codes, slot isolation testing, voltage verification, compatibility checking, ECC error detection.

\chapter{Storage Controller Interfaces}
SATA controller, AHCI vs RAID mode, NVMe controller, M.2 key types (B, M, B+M), PCIe lane allocation, hot-swap capability, TRIM command.

\chapter{Hard Drive Diagnostic Tools}
SMART attributes (reallocated sectors, pending sectors, CRC errors), surface scan, bad sector mapping, firmware corruption, mechanical failure sounds (clicking, grinding).

\chapter{SSD Architecture and Diagnostics}
NAND flash types (SLC, MLC, TLC, QLC), wear leveling, garbage collection, over-provisioning, TRIM effectiveness, SSD-specific SMART attributes, controller firmware updates.

%----------------------------------------------
% COMMON DIAGNOSTIC TECHNIQUES
%----------------------------------------------

\chapter{Thermal Management System Analysis}
Heat sink design, thermal paste application, thermal pads, heat pipe operation, vapor chamber cooling, thermal interface material (TIM) degradation, temperature monitoring (thermal diodes, thermistors).

\chapter{Voltage Regulation Module (VRM) Operation}
Buck converter topology, PWM controller, MOSFET switching, inductor selection, output capacitor filtering, load line calibration, voltage droop, VRM phase count.

\chapter{Component-Level Voltage Testing}
Reference voltage points, power rail sequencing, voltage ripple measurement, load-induced voltage drop, ground plane continuity, short circuit detection.

\chapter{Circuit Board Visual Inspection}
Burnt components identification, electrolytic capacitor failure (bulging, leaking), cold solder joints, cracked traces, corrosion detection, flux residue, water damage indicators.

\chapter{Multimeter Diagnostic Techniques}
Continuity testing, diode testing mode, capacitor ESR estimation, resistance measurement interpretation, AC/DC voltage verification, current measurement safety.

\chapter{Oscilloscope Diagnostics for Repair}
Signal integrity verification, clock signal analysis, power supply ripple measurement, PWM duty cycle measurement, trigger setup, probe compensation, bandwidth requirements.

\chapter{Logic Analyzer for Bus Debugging}
I2C bus analysis, SPI communication verification, USB signal quality, protocol decoding, timing violation detection, multi-channel capture.

\chapter{Component Identification and Datasheet Reading}
SMD marking codes, component package types (SOT, SOIC, QFN, BGA), pin 1 identification, polarity markings, datasheet interpretation (absolute maximum ratings, typical operating conditions).

\chapter{Schematic and PCB Layout Reading}
Schematic symbol conventions, net naming, component reference designators, power and ground symbols, PCB layer stackup, trace routing, via types, copper pour, silkscreen interpretation.

%----------------------------------------------
% PRACTICAL REPAIR TECHNIQUES
%----------------------------------------------

\chapter{SMD Soldering and Desoldering}
Soldering iron temperature control, flux application, component alignment, heat dissipation management, hot air rework station usage, desoldering braid, solder sucker.

\chapter{BGA and QFN Rework Techniques}
Ball grid array structure, reflow profile (preheat, soak, reflow, cooling), X-ray inspection, underfill removal, stencil alignment, solder ball placement.

\chapter{Microsoldering Under Microscope}
Magnification selection, lighting techniques, steady hand positioning, tweezers usage, fine-pitch component handling, flux pen application, solder wire diameter selection.

\chapter{Component Replacement Decision Matrix}
Cost-benefit analysis, availability considerations, compatibility verification, firmware dependencies, security chip replacement implications, serialized component handling.

\chapter{ESD Protection During Repair}
Electrostatic discharge fundamentals, wrist strap usage, ESD mat grounding, ionizer benefits, component handling procedures, humidity control, triboelectric series.

\chapter{Diagnostic Flowchart Construction}
Symptom identification, component isolation, probability-based testing order, decision tree optimization, documentation importance, feedback loop integration.

\chapter{Firmware and BIOS Diagnostics}
BIOS POST codes, UEFI firmware interface, CMOS battery replacement, BIOS recovery modes, firmware corruption detection, update procedures, downgrade considerations.

\chapter{Power-On Self-Test (POST) Analysis}
POST sequence stages, beep code interpretation by manufacturer, LED diagnostic codes, minimal POST configuration, component isolation testing, POST card usage.

\chapter{No Power Diagnosis Methodology}
Power button continuity, PSU verification, motherboard standby voltage, short circuit detection, component-by-component isolation, breadboard testing.

\chapter{No Display Troubleshooting}
Monitor vs system isolation, GPU reseating, CMOS reset, RAM testing, integrated vs discrete graphics, display cable verification, external display testing.

\chapter{Intermittent Fault Diagnosis}
Temperature-dependent failures, connector oxidation, solder joint cracking, capacitor degradation, environmental factor correlation, stress testing.

\chapter{Water Damage Recovery Procedures}
Immediate power disconnection, disassembly urgency, ultrasonic cleaning, isopropyl alcohol washing, corrosion neutralization, drying time requirements, component-level inspection.

\chapter{Board-Level Troubleshooting Strategy}
Power rail verification sequence, signal path tracing, component substitution testing, known-good board comparison, documentation review, community knowledge utilization.

%----------------------------------------------
% MOBILE-SPECIFIC REPAIR
%----------------------------------------------

\chapter{Mobile Device Disassembly Techniques}
Adhesive removal (heat gun, isopropyl alcohol), spudger usage, screw organization, cable connector types (ZIF, FPC, BTB), shielding can removal, warranty seal implications.

\chapter{Mobile Display Assembly Replacement}
Digitizer vs LCD separation, frame transfer, adhesive application, cable routing, testing before full assembly, touch calibration, backlight testing.

\chapter{Mobile Battery Replacement Procedures}
Adhesive strip removal, pull tab technique, battery connector identification, swelling detection, capacity verification, recycling considerations, calibration requirements.

\chapter{Mobile Charging Port Replacement}
Daughterboard identification, flex cable replacement, direct mainboard soldering, pin alignment verification, USB-C orientation testing, data line continuity.

\chapter{Mobile IC-Level Repair Techniques}
Hotplate vs hot air station selection, flux type for rework, underfill challenges, shield can handling, thermal coupling considerations, component height matching.

\chapter{Mobile Baseband Repair and IMEI}
Baseband processor role, IMEI storage locations, legal considerations, carrier lock implications, baseband firmware flashing, signal strength testing.

\chapter{Mobile Microphone and Speaker Replacement}
Component location identification, adhesive vs clip mounting, polarity verification, sound quality testing, water damage impact, mesh cleaning.

%----------------------------------------------
% COMPUTER-SPECIFIC REPAIR
%----------------------------------------------

\chapter{Desktop Motherboard Diagnostic LEDs}
Debug LED interpretation, CPU, RAM, VGA, BOOT sequence indicators, Q-code displays, troubleshooting based on LED patterns.

\chapter{CPU Installation and Socket Inspection}
LGA vs PGA socket types, pin damage assessment, bent pin straightening techniques, thermal paste application patterns, mounting pressure, cooler compatibility.

\chapter{GPU Troubleshooting and Repair}
Artifacting causes, memory chip failure, VRM failure, reflow as temporary fix, VRAM testing, power connector verification, driver vs hardware isolation.

\chapter{Storage Device Recovery Techniques}
Logical vs physical failure, partition table corruption, filesystem repair, firmware corruption, PCB swap considerations, data recovery services, clean room requirements.

\chapter{Laptop-Specific Repair Challenges}
Proprietary components, serviceability variation, keyboard replacement, screen hinge repair, DC jack replacement, trackpad connector issues, cooling system maintenance.

\chapter{Network Interface Diagnostics}
Ethernet PHY testing, link light interpretation, loopback testing, MAC address verification, speed negotiation issues, cable tester usage.

\chapter{USB Port Repair and Diagnosis}
USB protocol layers (physical, link, transaction), port power issues, data line integrity, device enumeration failure, controller chip identification, per-port fuse/limiting.

\chapter{Audio System Troubleshooting}
Codec chip identification, HD Audio vs AC'97, front panel header pinout, impedance sensing, pop/click diagnosis, amplifier testing, line-out vs headphone-out.

%----------------------------------------------
% ADVANCED DIAGNOSTIC EQUIPMENT
%----------------------------------------------

\chapter{Thermal Imaging for Fault Detection}
Infrared camera operation, thermal hotspot identification, component overheating patterns, short circuit localization, VRM phase imbalance detection.

\chapter{Power Supply Load Testing}
Electronic load usage, dynamic load testing, cross-load testing, hold-up time measurement, transient response testing, aging effects.

\chapter{Signal Integrity Testing Equipment}
Time-domain reflectometry (TDR), vector network analyzer (VNA), bit error rate testing (BERT), eye diagram analysis, jitter measurement.

\chapter{X-Ray Inspection for BGA Repair}
X-ray system operation, void detection in solder balls, bridge identification, component alignment verification, non-destructive testing benefits.

\chapter{Micro-Rework Station Setup}
Hot air station temperature profiling, preheater usage, fume extraction, ESD-safe workspace, tool organization, component storage, microscope positioning.

%----------------------------------------------
% PROFESSIONAL PRACTICES
%----------------------------------------------

\chapter{Repair Documentation Best Practices}
Photography during disassembly, screw mapping, cable routing documentation, settings preservation (BIOS, driver versions), customer communication, warranty tracking.

\chapter{Component Sourcing and Authenticity}
Genuine vs counterfeit parts, supplier reliability, date code interpretation, packaging inspection, electrical testing for verification, gray market risks.

\chapter{Repair Cost-Benefit Analysis}
Labor time estimation, parts cost, tool amortization, success probability, data recovery value, replacement cost comparison, customer budget consideration.

\chapter{Safety Protocols in Electronics Repair}
Capacitor discharge procedures, lithium battery handling, lead-free vs leaded solder, ventilation requirements, fire safety, chemical handling (flux, cleaning agents).

\chapter{Professional Tool Selection for Repair}
Investment priority, quality vs cost tradeoff, calibration requirements, maintenance needs, ergonomics, expandability, brand comparison.

\chapter{Repair Business Quality Assurance}
Post-repair testing checklist, burn-in testing duration, stress testing tools, warranty period determination, failure rate tracking, customer satisfaction metrics.

%----------------------------------------------
% SPECIALIZED TOPICS
%----------------------------------------------

\chapter{Retro Hardware Repair Techniques}
Capacitor replacement (recapping), tantalum capacitor substitution, BIOS battery replacement, floppy drive alignment, CRT monitor safety, vintage connector types.

\chapter{Industrial and Embedded System Repair}
Extended temperature component identification, conformal coating removal, ruggedized hardware, industrial power supplies, legacy protocol support, long-term availability.

\chapter{Server Hardware Diagnostics}
IPMI and BMC functionality, out-of-band management, SEL (System Event Log) analysis, predictive failure analysis, redundant component testing, hot-swap procedures.

\chapter{Repair Training and Skill Development}
Deliberate practice strategies, sacrificial board usage, component identification games, soldering certification programs, online community resources, mentorship importance.

\chapter{Design for Testability}
Scan chains, built-in self-test (BIST), fault injection, manufacturing test.

\chapter{Hardware Description Languages}
Verilog and SystemVerilog, VHDL, behavioral vs. structural modeling, simulation vs. synthesis.

\chapter{Digital Design Flow}
RTL design, logic synthesis, place and route, timing closure, physical design.

\chapter{FPGA Architecture}
Look-up tables (LUTs), configurable logic blocks (CLBs), programmable interconnect, block RAM, DSP slices.

\chapter{ASIC vs. FPGA Tradeoffs}
Performance, power, cost, flexibility, development time, reconfigurability.